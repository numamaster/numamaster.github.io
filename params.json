{"name":"Numamaster.GitHub.io","tagline":"Documentation for Numa Performance Tools shared among some Masterstudents","body":"### NUMA Infos\r\n##hpc-toolkit\r\n0. Die Measurement-Tools sind auf der Maschine installiert\r\n1. Ladet euch **hpcviewer** und **hpctraceviewer** für eure Plattform [hier](http://hpctoolkit.org/download/hpcviewer/)runter.\r\n_Nun zur Messung_\r\n2. Euer Programm mit `-g` (debug)  kompillieren, ruhig auch `-O3` verwenden.\r\n3. Das Programm mit **trace** aufnehmen. Hierbei kann man verschiedene Events mit `-e event@period` messen. Die verfügbaren Events sind unter `hpcrun -l` zu finden.\r\n```\r\n  $hpcrun -t -e event@period  ./<program>\r\n```\r\n4. Programmstruktur ermitteln:\r\n```\r\n  $hpcstruct <program>\r\n```\r\n5. Die in den vorherigen Schritten erstellen Dateien/Ordner zu einer\r\nProfile-Database zusammenstellen:\r\n```\r\n  $hpcprof -S <program>.hpstruct -I  </path/to/source> hpctoolkit-<program>-measurements1\r\n```\r\n6. Den Datenbankordner mit hpcviever und hpctraceviewer anschauen!\r\n\r\n#perf numa \r\nBecause there is no documentation, I try to understand the Code.\r\n\r\n##Options\r\n####Threads\r\n-p \\--nr_proc ( number of processes)\r\n-t \\--nr_threads (number of threads per process)\r\n####Data Amount\r\n-G \\--mb_global MB\t(global  memory (MBs))\r\n-P \\--mb_proc MB\t(process memory (MBs))\r\n-L \\--mb_proc_locked MB\t(\tprocess serialized/locked memory access (MBs)<= process_memory)\r\n-T \\--mb_thread MB\t (thread  memory (MBs))\r\n####Benchmark Duration\r\n-l \\--nr_loops (max number of loops to run)\r\n-s \\--nr_secs (max number of seconds to run)\r\n-u \\--usleep (usecs to sleep per loop iteration)\r\n####Data-Access\r\n-R \\--data_reads (access the data via writes (can be mixed with -W))\r\n-W \\--data_writes (access the data via writes (can be mixed with -R))\r\n-B \\--data_backwards (access the data backwards as well)\r\n-Z \\--data_zero_memset (access the data via glibc bzero only)\r\n-r \\--data_rand_walk (access the data with random (32bit LFSR) walk)\r\n```\r\n#define BIT(x) (1ul << x)\r\nstatic inline uint32_t lfsr_32(uint32_t lfsr)\r\n{\r\n\tconst uint32_t taps = BIT(1) | BIT(5) | BIT(6) | BIT(31);\r\n\treturn (lfsr>>1) ^ ((0x0u - (lfsr & 0x1u)) & taps);\r\n}\r\n```\r\n####Data-Init\r\n-z \\--init_zero (bzero the initial allocations)\r\n-I \\--init_random (randomize the contents of the initial allocations)\r\n-0 \\--init_cpu0 (do the initial allocations on CPU#0)\r\n-x \\--perturb_secs (perturb thread 0/0 every X secs\tto test convergence stability)\r\n####Misc\r\n**-d \\--show_details (Show details)**\r\n-a \\--all (Run all tests in the suite)\r\n-H \\--thp (MADV_NOHUGEPAGE < 0 < MADV_HUGEPAGE)\r\n-c \\--show_convergence (show convergence details)\r\n-m \\--measure_convergence (measure convergence latency)\r\n-q \\--quiet (bzero the initial allocations)\r\n-S \\--serialize-startup (serialize thread startup)\r\n\r\n####Examples\r\n```\r\nperf bench numa mem -p 4 -t 4 -P 1024 -C 0 -M 0 -s 20 -zZq --thp 1 -d\r\n```\r\n measures with **4 processors** and **4 threads each**.**1024 MB** of data are measured for **20secs**, **Zero-initialized**, accessed via **glibc bzero** with **1GB [THP] https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-transhuge.html** in **debug mode**.\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}